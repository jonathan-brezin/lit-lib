#!/usr/bin/env ruby
=begin <head>
Title: Literate Programming Support Via Markdown
Author: Jonathan Brezin
Date: February, 2017
Show source: Yes
Tab Size: 3
=end
require "awesome_print"
require "cmdline"
require "dbg"
require "fileutils"
require "sysutils"
require "versioning"
class LiterateSource
   VERSION       = "1.0.1"
   UPDATED       = "2017-07-11"

=begin <md>

## What <code>litsrc</code> does ##

The idea is to create document formats that are either legal Python or Ruby source code while
permitting one to include [markdown](http://pandoc.org) with the source in order to be able to 
create a document that the [`pandoc` command](http://pandoc.org/MANUAL.html#pandocs- markdown)
can then transform into HTML.  This is classic "literate programming".  By making the "literate"
version still syntactically correct, one can use any syntax-directed editor to create the code
without losing any of the editor's advantages.

Both languages have stylized multiline comments/strings that can be used to partition the source
file into  commentary and code.  For Python, triply quoted strings are used, and for Ruby
`=begin` multi-line comments.  I'll get to the details of `litsrc` syntax shortly, but first a
few more words on what it is I am and am _not_ trying to accomplish.

### `litcoffee` provided my inspiration

I discovered [`CoffeeScript`](http://coffeescript.org) and its literate dialect, `litcoffee`, a few
years ago.  Once I started writing `litcoffee`, I found myself much more inclined than I ever had
been before (and for me, "before" goes back to the late 1970s) to produce the kind of documentation
for my code that I knew that I should, and that a year or so later I knew I would appreciate.  The
sheer simplicity (indented source code, all else comments) and the relatively uncluttered final
source document were an invitation to "write big", which during the early development stages I have
found to be a real help.  That was the initial motivation: to make Python and Ruby, which along with
litcoffee are the languages I use a lot today, as inviting.  The `LiterateSource` class here is
deliberately generic, so as my programming interests change, new languages can easily be
accommodated.  For now, there are the [`rubymd`](rubymd.html) and [`panpype`](panpype.html)
commands.

Literate programming is hardly new, but somehow, even relatively accessible tools, like
[Javadoc,](http://www.oracle.com/technetwork/java/javase/documentation/index-jsp-135444.html) never
made me want to write enough.  Thinking about it now, I believe the new ingredient that tipped the
balance was markdown, as implemented by [Pandoc](http://pandoc.org). 

> In order to use `panpype` and `rubymd`, you need to install `pandoc`.  The instructions for doing
so are to be found at <a href="https://pandoc.org/installing.html">pandoc.org/installing.html</a>.
`pandoc` is a very useful tool in its own right.

I can't tell you why that is so, because it was not all that hard to produce attractive, readable
documentation with Javadoc. One factor is that the discpline that Javadoc imposes on you with the
various "`@`" tags is not always what I'd like, and it leads to source that is cluttered.  Its
formalized output has the virtue of providing the reader with a clear mental picture, even before
the details come into focus, but the same formalism makes the commentary feel utterly tied to the
local object of which the  commentary is a part.  While this makes good sense for a finished
product, I don't think it does for code that is in flux.   I could say the same thing about the
formalized comments that are the rule for [`pydoc`](https://www.python.org/dev/peps/pep-0257/) and
[`rdoc`](https://ruby.github.io/rdoc/). Their virtue is the discipline they impose.  There are times
when that discipline is worthwhile, times when (at least in my opinion) it is not.  `litcoffee`
encourages you to unfold your story more flexibly, and that is where I wanted to go.

>  I am sure I am not alone in preferring a world in which the source code is not interrupted with
commentary any more than is necessary.  That's why I've gotten in the habit of grouping sets of
related methods and putting their documentation in a block immediately preceeding them, rather than
keeping each method's comments with it. The key word here is "related".  The grouping of the
comments, and the grouping of the methods, provide helpful visual clue for grokking the code as a
whole.  This file is an example, and for another, look at [`dbgclient`](dbgclient.html). It had two
sets of methods for producing output, one for the class and one for instances.  Each has three
methods.  Each threesome fits on a screen, which makes the reasons for the slight differences in
their signatures visible. Also, if you open two windows, you can do a side-by-side comparison of the
two sets to see what is common code and what is different. All this with no commentary to distract
you.  Important? No, not really.  But I find it helpful.

Another virtue of `litcoffee` is that it allows one to produce output that contains some or all
of the source code together with the commentary in an elegant format, syntax coloring included.
It was not easy to do that with Javadoc in its early days when I was using it extensively.
[Perhaps things are different
now.](http://docs.oracle.com/javase/1.5.0/docs/guide/javadoc/doclet/overview.html) The example
of [JavaDoq](http://www.javadoq.com) would seem to say that it might be.

### But there are limits

What I am definitely not trying to accomplish is to replace rich development environments like
[Jupyter](http://jupyter.org).  I just wanted something minimal for the short kinds of projects
(5,000 to 10,000 lines of source) that I dabble in.   On the other hand, most of the work to be
done is langauge independent, so it seemed sensible to have the core classes here written so
that they could easily be extended to handle other languages.

## The <code>litsrc</code> document structure ##

A `litsrc` source file is partitioned into sections, of which there are three types.  There are
blocks of source code, of course.  The document's markup begins with an optional "head" section
analogous to an HTML `<head>` element.  The other sections are markdown commentary on the code.
The code sections are extracted and written to a file of the appropriate type (`.py` or `.rb`).
The markdown sections and some or all of the source code are written to a temporary file that is
processed by `pandoc`.  The  default is to hide all of the code sections from the `pandoc`
input.  You can use an entry in the head section to reverse that default, and you can include or
exclude the source code from the `pandoc` output on a line by line basis.

### Head Sections:

A `head` section, if present at all, begins the document, except perhaps for a few lines of
source code. It serves two purposes.   First, it is where you put the document title, author and
date information that is to be inserted at the start of the ".md" file.  This data is introduced
by the keywords

<pre class="exampleCode">
Title:
Author:
Date:
</pre>

Each of these ingredients should start at the beginning of a line, as should the two "pretty
printing" options described below.  The title and author information can be as many lines as you
need. Each ends either at the next keyword-initiated line or at the end of the head section.

The head section's second purpose is to allow you to provide some defaults as to what is
included in the markdown output.  By default, none of the source code is copied into the file
passed to `pandoc`.  Add the line

<pre class="exampleCode">
Show source: yes
</pre>

in the head to show all source as the file-wide default.  The "yes" value is case insensitive.

As I said earlier, there is [markup](#src_code) that allows you to override this file-wide
default locally in the literate source file. I should also say that the command line option to
show source (or not!) overrides this default, _but the explicit local overrides in the document
body are respected, whatever the command line and head say._  You can therefore keep all of the
source shown or hidden by using a local "show" or hide" request  (whose syntax is source-
language dependent) immediately before the first source code line.

Another pretty-printing issue, at least when the source is not hidden, is the tab size.  By
default, tabs are treated as 3 spaces, because that happens to be what I like.  If you want some
other size, _`n`_, add the line
<pre class="exampleCode">
Tab Size: n
</pre>
to the head section.  

Unless you request a tab size of `0`, all tabs are replaced by spaces in the output files.

Finally, for languages like Python where relative indentation has syntactic force, it is nice to
be able to indent the markdown commentary in such a way as not to do violence to the source
code's layout.  To that end, the [default](#marking_up) is to shift markdown left just far
enough so that the opening tag line is at the beginning of the line.  You can override that
default in the language spec for each new language, and for a particular file by including in
the head

<pre class="exampleCode">
Left justify markdown: [yes|no]
</pre>

to turn it on or off.  Again the value, "yes" or "no" is case-insensitive.

### Markdown Sections:

The content is markdown as implemented by the `pandoc` command as documented in
[pandoc.org/MANUAL.html#pandocs-markdown](pandoc.org/MANUAL.html#pandocs-markdown).
Sample code in the commentary (as opposed to source code) can be supplied in the markdown 
sections as an HTML section tagged `<pre class="exampleCode">`.  

### Source code sections {#src_code}

Any content not in either a head or markdown section is normal, ready-to-roll source code:
Python, Ruby, or whatever other extensions of this code folks choose to write. At any point in a
code section you can put a "show" or "hide" directive.  It should occupy a whole line.  For Ruby
and Python, I chose "`#==> <show>`" to turn displaying on, and "`#==> <hide>`" to turn it off.
These directives affect only the HTML output; they have no effect whatsoever on the source file
that is extracted from the literate source.

## The command-line interface {#the_cli}

The command for invoking the parse is `litsrc`.  It produces an HTML file and a code file that
is the source file stripped of all of the markdown.  The intermediate ".md" file that is
generated to pass to `pandoc` is normally discarded, but it will be kept if the "`-dbg`" option,
which governs debugging output, has "`md`" among its values.

<blockquote>
 Option              Purpose                                                            Default
---------------   -----------------------------------------------------------------   ----------
_`-root`_&nbsp;   src, doc and md are all relative to this path if they are relative   `"."`
_`-src`_&nbsp;    where to find the source code files                                 `"src"`
_`-css`_&nbsp;    where to find the .css file to send to pandoc.                      `"css"`
_`-bak`_&nbsp;    path for backups relative to directory backed up                    `"bak"`
_`-doc`_&nbsp;    where to write the "`.html` files                                   `"doc"`  
_`-md`_&nbsp;     where to write the "`.md`" files, if they are to be saved           `"md"`
_`-lib`_&nbsp;    where to write the stripped source code files.                      `"lib"`
_`-pub`_&nbsp;    root directory for published version of the package                  `""`
_`-s`_&nbsp;      also: `--show-source`: include the source code in the .html file?    `"?"`  
_`-a`_&nbsp;      also: `--assure`: create any missing output directories             `true`
_`-dbg`_&nbsp;    also: `--debug`: comma-separated keys to filter debugging output     `""`
_`-keep`_&nbsp;   the number of backups of the various output files to keep.            `5`
_`-tabs`_&nbsp;   the size of a tab stop--more on this attribute below.                 `3`
---------------   -----------------------------------------------------------------   ---------

<b><i>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
<code>litsrc</code> command-line options</i></b>

</blockquote>

The list of input sources to be processed follows the options in the command line. For example:

<blockquote>
the `rubymd` command uses an extension of `LiterateSource` called "`RubyMd`" to process literate
Ruby files with extension `.rbmd`.  Executing

<pre class="exampleCode">

rubymd -root good stuff.rbmd

</pre>
</blockquote>

will look for the file `stuff.rbmd` in the directory `./good/src` and will send its output files
`stuff.html` and `stuff.rb` to the directories `./good/doc` and`./good/lib`, respectively.  The
backups for `stuff.html` will be kept in `./good/doc/bak`, and similarly for the `.rb` files.

The normal overall structure for the directories is:

<pre class="exampleCode">

root
   src         # literate markdown source
   lib         # executables
      bak      # backups for the executables: default keep last 5 
   doc         # HTML output
      css      # stylesheets used by the HTML files
      examples # code that tests the lib entries and illustrates the commentary
      bak      # backups for the HTML, same default as for executables
   md          # saved markdown output -- optional and normally not needed
      bak      # backups for the markdown, same default as for executables

</pre>

There are times when it is really convenient for you as developer to work in the source
directory, not its parent or even further up the directory tree.  If, in the command line,
neither "`root`" nor "`src`" is supplied, the current working directory is used for the root,
and the source directory is its "`src`" subdirectory.  If only the "`src`" option is supplied,
then `root` is taken to be the parent directory of that directory.  _The idea is that the
remaining output directories should normally be siblings of the source directory._  Thus, the
command for literate Ruby source

<pre class="exampleCode">

rubymd -src . stuff.rbmd

</pre>

will make the current directory the location of the source file `stuff.rbmd`, and cause the root
directory to be its parent, "`..`", for purposes of writing the output files.

Of course, there is nothing to stop you from explicitly specifying both the root and the source
directories if you want the output separated from the source, and indeed, all of the various
directories are at your command.  Remember. though, that relative paths are always taken
relative to the root directory, however that directory wound up being specified.  Smart folks
live with my conventions, even if they don't like them.

### The `-s` and `--show_source` option

This option takes a single string value.  If you do not supply the option, it will be assumed
that what you mean is "I don't care.  Do whatever the file's head says, but if the file doesn't
say anything, hide the source code."  If you supply the option with `"yes"` as its value, the
source code will be shown in the HTML output, except as overridden locally in the file.  If the
value is `"no"`, it will not be displayed--except, again, unless overridden locally.

### The `-tabs` command line option

The `tabs` attribute also requires a few words of explanation.  If its value is not 0, tabs in
the input source will be replaced with spaces before any parsing is done, and the detabbed
source will be used for the code output. If the value is 0, though, _no cleanup at all is done
to the input._   The tab size can be supplied for each file individually by including the
desired value in the head.  The `tabs` parameter here is used as the default.  Any integer from
1 to 8 is okay for the value if you want tabs replaced.  Positive values out of that range will
be  replaced by `1+(n-1)%8`, e.g.: a value a `12` will get replaced by `4`.

### The <code>addCmdlineParameters(spec)</code> method

This method is meant to be called as part of the block executed to set up the [command line
processing](cmdline.html).  The command line options described above are registered with the
command line processor.  See the call to `CmdLine.parse` in [rubymd.html](rubymd.html) for an
example of  how it is intended to be used.  There is no return value.

=end

   def self.addCmdlineParameters(spec)
      app      = spec.appname
      from_ext = spec.help_info[:from]
      to_ext   = spec.help_info[:to]
      spec.add_help(
         before: "#{app} transforms .#{from_ext} files into .html and .#{to_ext} files.\n",
         after: "See litsrc.html for more details.")
      spec.add_version(version: LiterateSource::VERSION,
         date: LiterateSource::UPDATED,
         appname: $PROGRAM_NAME)
      spec.add_string('-root',
         default: '',
         help: 'src, doc, and md are all relative to this path when they are relative')
      spec.add_string('-pub',
         default: '',
         help: 'if this is not "", it is the root directory for publishing the project')
      spec.add_string('-src',
         help: 'where to find the source',
         default: "src")
      spec.add_string('-doc',
         help: 'where to put the .html output ',
         default: "doc")
      spec.add_string('-rb',
         help: 'where to put the .rb output ',
         default: "rb")
      spec.add_string('-bak', 
         help: 'where to put backups relative to the directory backed up',
         default: "bak")
      spec.add_string('-css', 
         help: 'where to find stylesheets relative to the doc directory ',
         default: "css")
      spec.add_csv("-dbg", "--debug", 
         help: 'comma-separated list of debug keys',
         optional: true)
      spec.add_flag("-a", "--assure", 
         help: "create any missing output directories",
         default: true )
      spec.add_string("-s", "--show-source", 
         help: "show the Ruby source in the HTML output",
         default: '?' )
      spec.add_integer("-keep", 
         help: "the number of backups to keep per output file",
         default: 3)
      spec.add_integer("-tabs",
         help: "the number of spaces per tab",
         default: 3)
      spec.add_list_here('files',
         help: 'source files',
         optional: true)
   end
end

=begin <md>

### Marking up the literate source: the class <code>LanguageSpec</code> {#marking_up}

There are a small number of language specific details that one needs to do the processing.  It
is a small number because I do not do any serious parsing.  I simply look for lines that match
one of a small set of patterns for starting and ending sections, and use those lines to
partition the literate source file.  I also need to know the language name and the file type
extension for the source code output file: ".py" and ".rb" for the Python and Ruby apps.
The basic story on the regular expressions for section boundary markers is

<table border="1" rules="cols" cellpadding="6px" align="center">
<tr><th>Python</th><th>Ruby</th><th>Purpose</th></tr>
<tr><td>`''' <head>`</td><td>`=begin <head>`</td><td>opens the head section, if there is one</td></tr>
<tr><td>`''' <md>`</td><td>`=begin <md>`</td><td>opens a markdown section</td></tr>
<tr><td>`''' (# </(md|head)>)?`</td><td>`=end (# </(md|head)>)?`</td><td>ends a head or md section</td></tr>
<tr><td>`#==> <show>`</td><td>`#==> <show>`</td><td>begin showing code in the HTML output</td></tr>
<tr><td>`#==> <hide>`</td><td>`#==> <hide>`</td><td>stop showing code in the HTML output</td></tr>
</table>

The idea here is that the start of a head or markdown section is signalled by a prefix that
begins a multi-line source-code comment, followed either by `"<head>"` or `"<md>"`, possibly
with some white space around it.  The ender for these sections is just the string normally used
to end a multi-line comment, possibly followed by a "to end of line comment" that affirms the
section type--_e.g._ "`''' # </md>`" to end a Python markdown section. The trailing HTML-like
ender is optional, but if present will be used to make sure that openers and enders are
appropriately paired. Nothing else may appear on either the opening or ending lines.

As for show and hide directives, they only require a single line, so I use the "ignore to end of
line" comment syntax, jazzed up a bit so as not to get in the way of normal comments in the code.  I
actually allow one or more spaces and/or tabs where a space is shown, and I allow "`<show
code>`" and "`<hide code>`", if you prefer that.

There are three other strings that I need to track,

- the default name for the `.css` file used by the HTML output files and\
- the two strings that one inserts into the markdown to begin and end code sections.

I use `pandoc`'s ["fenced code block" notation](http://pandoc.org/MANUAL.html#fenced-code-
blocks) to bracket the code sections in the `.md` file.  The end marker is language independent:
a string of tildes of long enough length will do.  It must be on its own line and be followed by
at least one blank line. The begin marker can allow one to take advantage of pandoc's syntax
hightlighting if it provides a language name that `pandoc` recognizes--_e.g._ `~~~~{.python}`.
To see a list of language names that `pandoc` does recognize, execute

<pre class="exampleCode">

pandoc --list-highlight-languages.

</pre>

The begin line must be preceeded by an empty line.  It may be followed immedately on the next
line by the code.  The upshot is that the fenced in code is separated from the surrounding
commentary by a pair of empty lines, one before and one after it.

I provided one final tidbit more or less just to accommodate Python, because (if only for
literate Python) it is nice to be able to indent the markdown commentary so as not to do too
much violence to the perceived structure of the code.  This runs into a `pandoc` convention,
which says that

> [a] block of text indented four spaces (or one tab) is treated as verbatim text: that is,
special characters do not trigger special formatting, and all spaces and line breaks are
preserved.

Therefore, I provided the `left_justify` option, which takes the value `true` to indicate that
the indentation of the begin marker for a markdown section holds for the whole section, and
therefore the whole section should be shifted left so that the begin marker is at the start of
its line.  The default for the option is `true`: it really is what you normally want.

The implementation keeps this information in an instance of a class called "`LanguageSpec`".

=end

class LanguageSpec
   attr_reader :begins, :hide_show, :ends, :lang, :left_justify_md, :lib_ext, :src_ext
   attr_accessor :begins_code, :default_css, :ends_code
   def initialize(
      lang_name, src_extension, lib_extension, begins_section, ends_section,
      hide_show, left_justify=false
   )
      lang_name    = lang_name.downcase
      @lang        = lang_name.capitalize
      @src_ext     = src_extension
      @lib_ext     = lib_extension
      @default_css = "#{lang_name}md.css"
      @begins      = if begins_section.kind_of? Regexp then begins_section 
                     else Regexp.new begins_section
                     end
      @ends        = if ends_section.kind_of? Regexp then ends_section
                     else Regexp.new ends_section
                     end
      @hide_show   = if hide_show.kind_of? Regexp then hide_show
                     else Regexp.new hide_show
                     end
      @begins_code = "\n~~~~~{.#{lang_name}}\n"
      @ends_code   = "\n~~~~~~~~~~~~~~\n\n"
      @left_justify_md = left_justify
   end
end

=begin <md>

## Programming Notes

From this point on, the documentation is intended entirely for those who want to work with the
source code for `LiterateSource`.

To begin with, in the definition of `LanguageSpec` above, the three regular expressions
should match an entire line.  For the two expressions that begin a feature, the thing begun
should be separated from the leader by at least one space and should be the second "word"
in the line.  That word should be exactly as shown in the tables for Python and Ruby above.

### The <code>LiterateSource</code> class

The intention was for this class to create a single instance from the command line options.
The initializer takes a single argument, the command line options as described above.  Any
object `obj` with methods `obj.root`, `obj.src`, and so on will do.  That is how the options
are accessed in the initializer: by method call, not property lookup: _i.e._ `obj.src`, not
`obj["src"]`.

The initializer for `LiterateSource` begins by setting up any debugging output requested by the
command line.  That output is handled by the [`DbgMgr` class](dbg.html).

The main job of the initializer is to establish the paths to the source directory and the
various output directories as described just above.  It also establishes the limits for the
number of backups (if any!) to be kept, and if there is no `.css` file in the `css` directory,
it creates a default file there.

>  Although there is rarely good reason to do so, the intermediate markdown ("`.md`") files 
can be saved as well.  They go into their own directory by default and are backed up with the
same discipline as the other output files.

=end

class LiterateSource

   attr_reader :root, :src, :css, :files,                     # input parameters
               :doc, :ext, :md, :pub, :keep, :assure, :tabs   # output parameters

   def initialize(options, lang_spec)
      @options = options
      @lang_spec = lang_spec
      if options.dbg.length > 0
         DbgMgr.add_patterns options.dbg
         if DbgMgr.active? 'file'
            File.debug_on 'file'
         else
            File.debug_off
         end
         DbgMgr.open
      end
      DbgMgr.add_patterns options.dbg
      DbgMgr.pre "opt", "---------\n#{options.to_s.gsub(" ", "\n   ")}\n---------", esc: true
      # Paths are relative to the "root":
      @root = options.root
      # Input paths
      begin
         get_the_source_paths options
         get_the_output_paths options, lang_spec
         get_the_css_path options.css, lang_spec.default_css
      rescue Exception => e
         DbgMgr.close
         raise e
      end
      DbgMgr.pre("paths",
          "Directory paths:\n    root=#{root}\n    src=#{@src}\n" +
          "    doc=#{@doc}\n    css=#{@css}\n    lib=#{@lib}\n    md=#{@md}"
          )
      # some admin stuff
      @show_source = options.s
      @head_index = -1
      @head = nil
   end

=begin <md>

There are two public instance methods: `process_files` to create the `doc` and `lib` files, and
`publish` to copy the `src`, `lib`, and `doc` directories to a new home. 

#### <code>process_files()</code>

that applications call to actually process the source files once the new `LiterateSource`
instance has been initialized.  It has no return value.

The code is pretty straightforwardly linear: for each literate source file, read it as an array
of lines, partition it into sections (kept in an array of `Section`s), extract and write out
the pure source sections, extract and write out the markdown output, then run the markdown
through the `pandoc` command to produce the HTML.

=end

   def process_files
      begin
         @files.each do |file|
            name = File.basename(file, File.extname(file))
            if not name.end_with? '.' then name += '.' end
            lines = File.readlines file
            sections = Sections.new lines, name, @options, @lang_spec
            if DbgMgr.active? "out"
               output = "non source sections:\n"
               sections.md_sections.each {|s| 
                  output += "  #{s.class}: #{s.first_in}...#{s.first_after}"
               }
               ouput += "\nruby sections\n"
               sections.lib_sections.each {|s|
                  output += "  #{s.class}: #{s.first_in}...#{s.first_after}"
               }
               DbgMgr.put "out", (output + "\nend\n")
            end
            write_the_lib_file name, lines, sections.sections
            md_file = write_the_md_file name, lines, sections.head, sections.sections
            if write_the_html_file md_file, name
               if  not @save_md
                  File.delete md_file
               end
            end
            DbgMgr.flush 
         end     
      rescue Exception => e
         DbgMgr.err e, now: true # flush the debugging buffer, but do NOT close the stream
      end
      DbgMgr.close
   end

   def publish
      if not @pub.nil?
         begin
            create_the_index
            populate_a_directory @src, @pub_src, @src_ext
            populate_a_directory @lib, @pub_lib, @lib_ext
            populate_a_directory @doc, @pub_doc, 'html'
            populate_a_directory @css, @pub_css, 'css'
            populate_a_directory @xmp, @pub_xmp, @lib_ext         
         rescue Exception => e
            DbgMgr.err e, now: true # flush the debugging buffer, but do NOT close the stream
         end
      end
      DbgMgr.close
   end

=begin <md>

### Preparing to read and write

Everything that follows is private to `LiterateSource`.  There is a group of methods for
organizing the input and output, and a group of methods for writing the output.  Reading the
source files is done in initializing an instance of the `Sections` class.  That class's 
definition follows the two method sets.  

#### <code>get_the_source_paths(options)</code>

uses the options and the [conventions discussed above](#the_cli) to set the instance variables
`@src` and `@files`.  The latter is an array consisting of the fully resolved, absolute paths
for the source files.

#### <code>get_the_output_paths(options)</code>

again uses the options to realize my path conventions, and in this case (unlike getting the
source paths) checks what files to write out and that the necessary directories actually
exist to which to write them.  In particular, the intermediate `.md` file is normally not
saved: add `"md"` to the list of debug keys held in `options.dbg` if you want to keep that
file around.  There is also the question of how many backup files should be kept.  The limit
is `options.keep`.  The backups are normally put in the `bak` subdirectory of the directory
holding the original.  If you wish a different name (perhaps `.bak` to hide them), use
options.bak.

#### <code>get_the_css_path(css_path, default_css_filename)</code>

The first argument is either the full path or the directory path for the `.css` file.  If it is
the directory path, the convention name for the file, `default_css_filename` will be appended.
If the file does not exist, a default version will be created.  The main objective here is to
specify the fonts and font sizes to be used in various parts of the HTML file.  It also
establishes the display parameters for example code and the real source code.


=end
   private
   def get_the_source_paths(options)
      @src = options.src
      DbgMgr.put "paths", "before: options src is '#{@src}' and @root is '#{@root}'"
      if @root.nil? or @root == ''
         if @src.nil?
            @root = Dir.getwd
            @src = File.normalized_path @root, child: 'src'
         else
            @src = File.absolute_path @src
            @root = File.parent_directory @src
         end
      else
         @root = File.absolute_path @root
         @src = File.normalized_path @root, child: 'src', alternate: @src
      end
      DbgMgr.put "paths", "after: options src is '#{@src}' and @root is '#{@root}'"
      @files = options.files.collect { | file | File.expand_path file, @src}
   end

   def get_the_output_paths(options, lang_spec)
      # the output paths
      @save_md = DbgMgr.active? "md"
      @doc = File.normalized_path @root, child: 'doc', alternate: options.doc
      @examples = File.normalized_path @doc, child: 'examples'
      @md = if @save_md then File.normalized_path @root, child: 'md', alternate: options.md
            else @doc
            end
      @lib = File.normalized_path @root, child: 'lib', alternate: options.lib
      @src_ext = lang_spec.src_ext
      @lib_ext = lang_spec.lib_ext
      if options.pub == ''
         @pub = @pub_src = @pub_lib = @pub_doc = @pub_css = @pub_xmp = nil
      else
         @pub = File.expand_path options.pub
         File.assure_directory @pub
         @pub_src = File.normalized_path @pub, child: 'src'
         @pub_lib = File.normalized_path @pub, child: 'lib'
         @pub_doc = File.normalized_path @pub, child: 'doc'
         @pub_css = File.normalized_path @doc, child: 'css'
         @pub_xmp = File.normalized_path @doc, child: 'examples'
         File.assure_directory @pub_src
         File.assure_directory @pub_lib
         File.assure_directory @pub_doc
         File.assure_directory @pub_css
         File.assure_directory @pub_xmp
      end
      if options.assure
         File.assure_directory @doc
         File.assure_directory @examples
         File.assure_directory @md if @save_md
         File.assure_directory @lib
      end
      # what previous output should be saved as backups?
      @keep = options.keep
      if @keep == 0 or options.bak.nil?
         @doc_bak = @md_bak = @lib_bak = nil
      else
         @doc_bak = File.normalized_path @doc, child: options.bak
         @md_bak = File.normalized_path @md, child: options.bak
         @lib_bak = File.normalized_path @lib, child: options.bak
         DbgMgr.pre("paths", "bak:\n    doc=#{@doc_bak}\n    md=#{@md_bak}\n    lib=#{@lib_bak}")
         if options.assure
            File.assure_directory @doc_bak if @doc != @doc_bak
            File.assure_directory @md_bak if @save_md and @md != @md_bak
            File.assure_directory @lib_bak if @lib != @lib_bak
         end
      end
   end

   DEFAULT_CSS = %q<
@media print { 
   body { font-size: 11pt; }
   pre { font-family: Courier; font-size: smaller; }
   .exampleCode {
      background-color: blanchedalmond !important;
      -webkit-print-color-adjust: exact; 
      font-family: Monaco; 
      font-size: 9pt;
   }
   .sourceCode  { 
      background-color: lightgray !important;
      -webkit-print-color-adjust: exact; 
      font-family: Courier; 
      font-size: 9pt; ]
    }
}
.author { text-align: center; font-size: 12pt; font-weight: bold; }
.date { text-align: center; font-size: smaller; }
code { font-family: Monaco; font-size: smaller; }
pre {
    -moz-tab-size:    3;
    -o-tab-size:      3;
    -webkit-tab-size: 3;
    -ms-tab-size:     3;
    tab-size:         3;
    line-height: 1.125em
}
@media screen {
   h4 { text-decoration: underline; }
   .exampleCode { background-color: blanchedalmond; font-family: Monaco; font-size: 9pt; }
   .sourceCode  { background-color: lightgray; font-family: Courier; font-size: 11pt;  }
}
.h1Code { font-family:Courier; font-size: 20pt; font-weight: normal; }
.h2Code { font-family:Courier; font-size: 18pt; font-weight: normal; }
.h3Code { font-family:Courier; font-size: 14pt; }
.title     { text-align: center;  font-size: 17pt; font-weight: bold;}}
.titleCode { font-family: Courier; font-size: 17pt; font-weight: normal; }
>
   def get_the_css_path(css_path, default_css_filename)
      #exists = File.exists? css_path
      css_path = File.expand_path css_path, @doc
      DbgMgr.put "in_css",  "css file at #{css_path}?"
      if File.exists?(css_path) and  File.directory?(css_path)
         css_path +=  "/#{default_css_filename}"
      end
      if not css_path.end_with? ".css"  # then it cannot be the file!
         File.assure_directory css_path # make sure it exists as a directory
         css_path += "/#{default_css_filename}" # and use the default file name
      end
      if not File.exists? css_path
         DbgMgr.warn "New .css file #{css_path} created."
         File.open(css_path, "w") { |io| io.puts DEFAULT_CSS }
      else
         DbgMgr.put "in_css", "using css file '#{css_path}'"
      end
      @css = css_path
   end

=begin <md>

### Writing the various output files

#### <code>write_the_html_file(mdpath, name)</code>

The first argument specifies the path for the `.md` input file.  The output file directory is
the `@doc` directory, and the file name is the second argument plus the usual `.html` extension.

All this method does is to set up and execute a call to `pandoc`.  The return value is an array
with two entries: the exit status from the `pandoc` call and the output (if any) to `stdout`
and `stderr` produced by `pandoc`.

#### <code>write_the_md_file(name, lines, head, sections) </code>
adds the file extension `.md` to `name` and loops over the `sections` array, writing out those
sections that are either markdown or visible code.  The output path is returned for immediate
use by `write_the_html_file`.

#### <code>write_the_lib_file(name, lines, all_sections)</code>

adds the language-dependent file extension to `name` and loops over the `sections` array,
writing out those sections that are code. 

=end

   def write_the_html_file(mdpath, name)
      DbgMgr.put "out_html", "writing #{name}html"
      file = File.join @doc, (name + "html")
      VersionedFile.new_version file, true, bak: @doc_bak, keep: @keep
      cmd = "pandoc  -p -s -S -f markdown -t html5 --toc --toc-depth=4 " +
            "--self-contained --css #{@css} -o #{file} #{mdpath}"
      DbgMgr.put "out_html", cmd
      output = %x[#{cmd}]
      [$?.exitstatus, output]

   end
   def write_the_md_file(name, lines, head, sections) 
      DbgMgr.put "out_md",  "Writing #{name}md!"
      begin
         keep = if @save_md then @keep else 0 end
         output_path = File.join @md, (name + "md")
         #show_source = if head.show.nil? then false else head.show
         VersionedFile.open(output_path, bak: @md_bak, keep: keep, mode: 'w') do |fd|
            fd.puts "% #{head.title}\n% #{head.author}\n% #{head.date}\n"
            sections.each {| section | section.to_md(fd) }
         end
      rescue Exception => ex
         DbgMgr.err ex, my_caller: "write_the_md_file"
         raise
      end
      output_path
   end

   def write_the_lib_file(name, lines, sections)
      DbgMgr.put "out_lib",  "Writing #{name}#{@lib_ext}!"
      begin
         file = File.join @lib, "#{name}#{@lib_ext}"
         VersionedFile.open(file, bak: @lib_bak, keep: @keep, mode: 'w') do |fd|
            sections.each { | section | section.to_lib fd }
         end 
      rescue Exception => ex
         DbgMgr.err ex, my_caller: "write_the_lib_file"
         raise
      end
   end
      
   def exec_cmd cmd, check_output = true
      DbgMgr.put "exec", cmd
      output = %x[#{cmd}]
      status = $?.exitstatus
      if status != 0 or (check_output and output != nil and output.length > 0)
          msg = "'#{cmd}' failed with exit status=#{exit_status}"
          if check_output
            msg += ", output='#{output}'"
          end
         STDERR.puts msg
         DbgMgr.warn output
         return false
      else
         DbgMgr.put "exec", "#{name}html created, exit code #{status}"
         return true
      end
  end

   def create_the_index
      pubname = File.basename @pub
      index_md = File.expand_path "index.md", @root
      if not File.exists(index_md)
         File.write index_md, "The source files for the #{pubname} package are:\n"+
            "<blockquote>\n<!-- source links -->\n</blockquote>\n"
      end
      index_in = File.new(index_md)
      ls_cmd = "ls #{@src}/*.#{@src_ext}"
      file_list = %x[ls_cmd].collect do |path|
         "[#{File.basename path}](path)"
      end
      Range.new(0, file_list.size() - 2).each do |n|
         file_list[n] += "\\\n"
      end
      temp_index_md = "#{@pub_doc}/index.md"
      File.open(temp_index_md, "w") do |out|
         line = index_in.gets
         while not line.nil?
            if line.strip.start_with? "<!-- source links -->"
               file_list.each do |line|
                  out.puts line
               end
            else
               out.puts line
            end
         end
      end
      file = File.join @pub_doc, "index.html"
      cmd = "pandoc  -p -s -S -f markdown -t html5 --toc --toc-depth=4 " +
            "--self-contained --css #{@css} -o #{file} #{temp_index_md}"
      if exec_cmd cmd
         return exec_cmd("rm #{temp_index_md}")
      end
      false 
   end

   def populate_a_directory src_path, tgt_path, extension
      # empty the target directory of files that have the same extension as
      # the copied files, and if that succeeds, do the copy from the source
      dead_files = File.join tgt_path, "*#{extension}"
      if exec_cmd "rm #{dead_files}"
         new_files = File.join src_path, "*#{extension}"
         return exec_cmd "cp #{new_files} #{tgt_path}"
      end
      false
   end

=begin <md>


### The <code>Section</code> class and its extensions, <code>Head</code>, <code>Markdown</code> and <code>Code</code>

A section is responsible for a set of lines.  It knows how to write them to the markdown and
lib files.  A section's line set is determined by two instance variables, `@first_in` and
`@first_after`.  A section has access to the array of lines from the literate source files,
and its responsibility is the range of lines `[@first_in ... @first_after]]`.  For `Markdown`
sections there is little more to say, other than that it is responsible for trimming leading
white space if left justification was requested.  As for the others:

`Code` sections are also straightforward: the only new ingredient is that they have a leader
and a trailer that they have to write to the markdown file so that `pandoc` will recognize this
as source code.  The `Head` section is where there is some real work to do, because it serves
two purposes: to provide the header block for the markdown and to track some file-wide defaults.
There are two cases.  If the author has supplied a head section, the file-wide defaults are
first taken from it, and then from the options.  If there is no head section, one is created
from the options, language specification and the file name.  Hence, rather than a single
public constructor, there is a pair of static methods to create a `Head` instance from the
appropriate input.


=end
   
   class Section
      attr_reader :first_in, :first_after
      def initialize(first_in, first_after, lines)
         @first_in = first_in
         @first_after = first_after
         @lines = lines
      end
      def to_s()
         "#{self.class}(#{@first_in}, #{@first_after})"
      end
   end

   class Head < Section
      attr_accessor :title, :author, :date, :tabsize, :show, :left_justify
      attr_reader :lines
      def self.newFromOptions(options, lang_spec, name)
         head = Head.new -1, 0, []
         head.set_from_defaults options, lang_spec, name
         head
      end

      def self.newFromLines(begins, ends, lines, options, lang_spec, name)
         head = Head.new begins, ends, lines
         head.set_from_lines 
         head.set_from_defaults options, lang_spec, name
         head
      end

      def initialize(first_in, first_after, lines)
         super first_in, first_after, lines
         @title = nil
         @author = nil
         @date = Date.today.iso8601
         @tabsize = nil
         @show = false
         @left_justify = false
      end

      KEYS = Set.new ['author', "date", 'show source', 'tab size', 'title']
      def set_from_lines()
         type = ''
         buffers = Hash.new ''
         (@first_in+1 ... @first_after).each do |n|
            line = @lines[n].rstrip
            if line.length == 0 then next
            elsif line[0] == " " or line[0] == "\t"
               if type != '' # this is a continuation line
                  buffers[type] += "\n "+line[1 .. -1] # get rid of the tab if one leads off
               else
                  raise SyntaxError.new "No section key for line #{n} in the head"
               end
            else
               line.lstrip!
               colon_index = line.index ':'
               if colon_index.nil? then possible_key = ''
               else 
                  possible_key = line[0 ... colon_index].downcase 
                  rest_of_line = line[colon_index+1 .. -1].lstrip
               end
               DbgMgr.put "head",  "#{possible_key} key?"
               if KEYS.member? possible_key
                  type = possible_key
                  if type == 'tab size'
                     @tabsize = Integer(rest_of_line)
                  elsif type == 'show source'
                     @show = rest_of_line.strip.to_b
                  else
                     if buffers[type].length > 0
                        buffers[type] += "\n  "
                     end
                     buffers[type] += line[colon_index+1 .. -1]
                  end
               elsif type != '' # may just be a ':' in an address or title continuation line
                  buffers[type] += "\n  " + line
               else
                  raise SyntaxError.new "Bad section key, #{type} for line #{n} in the head"
               end
            end
         end
         if buffers.member? "title" then @title = buffers["title"] end
         if buffers.member? "author" then @author = buffers["author"] end
         if buffers.member? "date" then @date = buffers["date"] end
         if buffers.member? "tab size" then @tabsize = Integer buffers["tab size"] end
         if buffers.member? "show source" then @show = buffers["show source"].to_b end
         if buffers.member? "left justify markdown"
            @left_justify = buffers["left justify markdown"]
         end
      end

      def set_from_defaults(options, lang_spec, name)
         if @title.nil? then @title = "#{name}.#{lang_spec.src_ext}" end
         if @date.nil? then @date = Date.today.iso8601 end
         if @tabsize.nil? then @tabsize = options.tabs end
         if @left_justify.nil? then @left_justify = lang_spec.left_justify_md end
         if options.s != '?' then @show = options.s.to_b 
         elsif @show.nil? then @show = false
         end
      end
      def to_md(fd)
         # do nothing!
      end
      def to_lib(fd)
         # do nothing!
      end
   end

   class Markdown < Section
      def initialize(section_spec, lines, undent)
         super section_spec.begins+1, section_spec.ends, lines
         @indent = if undent then section_spec.indent else 0 end
      end
      def to_md(fd)
         if @indent == 0
            (@first_in ... @first_after).each do |n|
               fd.puts @lines[n] 
            end
         else # trim on the  left to justify the markdown
            (@first_in ... @first_after).each do |n|
               line = @lines[n]
               fd.puts line[@indent ... line.length]
            end
         end
      end
      def to_lib(fd)
         # do nothing!
      end
   end

   class Code < Section 
      def initialize(first_in, first_after, lines, show, lang_spec)
         super first_in, first_after, lines
         @show    = show.to_b
         @leader  = lang_spec.begins_code
         @trailer = lang_spec.ends_code
      end
      def to_md(fd)
         if @show
            fd.puts @leader # pandoc "fence": \n~~~~{.lang_name}\n
            (@first_in ... @first_after).each {|n| fd.puts @lines[n]}
            fd.puts @trailer # pandoc "fence": ~~~~~~\n\n
         end
      end
      def to_lib(fd)
         (@first_in ... @first_after).each {|n| fd.puts @lines[n]}
      end
   end

=begin <md>

### The <code>Sections</code> class: parses the input into a list of `Section`s 

The constructor does all the work!  An instance of this class is a set of "section specs".
where the start and end lines are, the indentation, and the kind.

#### <code>Sections(lines, name, options, lang_spec)</code>

The first argument, `lines`, is the input file as a list of lines.  The second argument, `name` is
the base name of the input file--_e.g._ `"litsrc"` for this file.  `options` is used to fill in
the entries in the `Head` section: tab size, whether to show source by default, etc..  The
`lang_spec` is a [`LanguageSpec`](#marking_up) instance.

Programming notes:  The first objective is to match the beginners to the enders and to find the
show/hide directives. This done in `find_the_section_specs`.  It loops first over the lines from the
input file.  For each begin tag and each directive, it creates a `SectionSpec` that tracks the begin
and end pairs for the markdown sections and the locations of the directives.  It also tracks the
indentation for begin tags.  Once the array of section specs is computed, the
`list_all_the_sections` method loops over the section specs array to find the code sections--that
is, those lines that are either not in markdown sections or are not directives.  It creates a
`Markdown` instance for each markdown section spec, and for each contiguous block of code lines with
the same "show" value, it creates a `Code` instance.  The array of these instances is the
`@sections` instance variable of the `Sections` instance.

=end
   
   class Sections
      SectionSpec = Struct.new :begins, :ends, :indent, :kind
      attr_reader :head, :sections
      def initialize(lines, name, options, lang_spec)
         @lines = lines
         @name = name
         @head = Head.newFromOptions options, lang_spec, @name
         section_specs = find_the_section_specs options, lang_spec
         @sections = list_all_the_sections section_specs, lang_spec
      end
      private
      def find_the_section_specs(options, lang_spec)
         section_specs = [SectionSpec.new(-1, -1, 0, :before)]
         last_start = -1
         type_started = :none
         indent = 0
         head_seen = false
         first_md = -1
         begins = lang_spec.begins
         ends = lang_spec.ends
         hide_show = lang_spec.hide_show
         @lines.each_with_index do | line, n | # find the head and md sections
            case 
            when (begins =~line) == 0
               last_start = n
               line = line.downcase
               if line.index("<head>") != nil
                  type_started = :head
                  if  first_md >= 0
                     raise SyntaxError.new "line #{n}: head section must come before any markdown"
                  elsif head_seen
                     raise SyntaxError.new "Second 'head' begun at line #{n}"
                  else 
                     head_seen = true
                  end
               elsif line.index("<md>") != nil
                  type_started = :md
                  indent = line.index /\S/
                  if first_md < 0 and (not head_seen) and @head.tabsize != 0
                     tabsize = @head.tabsize
                     @lines = @lines.collect { |line| line.expandtabs tabsize}
                  end
               else
                  raise SyntaxError.new "Unexpected begin line match: '#{@lines[n]}'"
               end
            when (ends =~ line) == 0
               end_match = /<\/(md|head)>[ \t]*\n?/.match(line)
               line_ender = if end_match.nil? then nil else line[end_match.captures[0]] end
               case type_started
               when :head
                  if line_ender.nil? or line_ender=='head'
                     section_specs.push SectionSpec.new(last_start, n, indent, :head)
                     @head = Head.newFromLines last_start, n, @lines, options, lang_spec, @name
                     if @head.tabsize != 0
                        @lines = @lines.collect { |line| line.expandtabs @head.tabsize}
                     end
                  else
                     SyntaxError.new "Bad ender, '#{line} 'for a <head> section"
                  end
               when :md 
                  if line_ender.nil? or line_ender=='md'
                     section_specs.push SectionSpec.new(last_start, n, indent, :md)
                  else
                     SyntaxError.new "Bad ender, '#{line}' for an <md> section"
                  end
               when :none
                  if not line_ender.nil?
                     raise SyntaxError.new "Unmatched ender '#{line}' at line #{n}"
                  end
               end
               last_start = -1
               type_started = :none
            when (hide_show =~ line) == 0
               if type_started == :none
                  line.downcase!
                  kind = if line.index("show") != nil then :show
                         elsif line.index("hide") != nil then :hide
                         else raise SyntaxError.new "unrecognized hide/show directive '#{line}'"
                         end
                  section_specs.push SectionSpec.new n, n, 0, kind
               else
                  msg = "directive '#{line.strip}' cannot sit in a(n) #{type_started} section"
                  raise SyntaxError.new msg
               end
            end
         end
         if type_started != :none
            msg = "Unexpected EOF with open #{type_started} at line #{last_start}"
            raise EOFError.new msg
         end
         section_specs.push SectionSpec.new @lines.length, @lines.length, 0, :ends
         DbgMgr.pre "section_specs", section_specs.to_s.gsub(/, #/, "\n #"), esc: true
         section_specs
      end

      def list_all_the_sections section_specs, lang_spec
         # Code sections can now be found as the lines not in the head or md sections
         sections = []
         prior_stop = -1     # the ends index or the directive index
         show = @head.show   # initially the default, then managed by directives
         left_justify = lang_spec.left_justify_md or @head.left_justify
         section_specs.each do |section_spec|
            first_code  = prior_stop + 1 
            prior_stop  = section_spec.ends  # first after the section delimited by section_spec
            if first_code < section_spec.begins # there may be some code immediately before
               code_section = Code.new first_code, section_spec.begins, @lines, show, lang_spec
               sections.push code_section
            end
            case section_spec.kind
            when :ends then return sections
            when :head then sections.push @head
            when :hide then show = false
            when :md   then sections.push Markdown.new section_spec, @lines, left_justify
            when :show then show = true
            else
               DbgMgr.put "out_list", "skip a #{section_spec.kind} section_spec" 
            end
         end
         raise Exception.new "Missing :ends SectionSpec"
      end
   end
end
